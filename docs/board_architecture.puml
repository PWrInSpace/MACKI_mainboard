@startuml Mainboard_architecture
skinparam ranksep 150
allow_mixing

!function $addedByGliwus()
!return "<color:"+White+"><back:"+Green+"><size:14><b><font:monospaced>"
!endfunction

component communication_interfaces{

    ' TODO: If uart for sure to RPi
    struct uart_interface {
        uint8_t purpose_mask;
        uart_driver* uart_driver;
        void on_log_received(char* log);
    }

    note top of uart_interface
        UART: Mainboard <-> RPi.
        Maybe multiple instances as RS485 could be used
    endnote

    struct usb_cdc_interface{
        uint8_t purpose_mask;
        usb_cdc_driver* usb_cdc_driver;
        void on_log_received(char* log);
    }

    note top of usb_cdc_interface
        USB_CDC: Mainboard <-> PC.
    endnote

    struct ble_interface{
        uint8_t purpose_mask;
        void on_log_received(char* log);
    }

    note top of ble_interface
        BLE: Mainboard <-> PC.
        Hardware turned off by default.
        Used only for ground testing
    endnote

    enum comm_purpose_mask{
        NONE = 0x000h, // should be turned off
        COMMAND_LINE = 0x001h,
        LOGGING = 0x010h,
        DATA_ACQUISITION = 0x100h,
    }

    note bottom of comm_purpose_mask
        $addedByGliwus() Mask for communication purposes
        $addedByGliwus() Can be switched on/off by the user for different interfaces
        $addedByGliwus() purpose_mask used in every component, then checked in the interface
    endnote

    uart_interface --o "uses" comm_purpose_mask
    ble_interface --o "uses" comm_purpose_mask
    usb_cdc_interface --o "uses" comm_purpose_mask

}

note top of communication_interfaces
    Interfaces for communication
    are global and static
endnote



component peripheral_interfaces{
    struct i2c_wrapper{

    }

    note top of i2c_wrapper
        Wrapper for the i2c instance
    endnote

    struct spi_wrapper{

    }

    note top of spi_wrapper
        Wrapper for the spi instance
    endnote
}

note left of peripheral_interfaces
    Interfaces for peripherals
    are global and static
    $addedByGliwus() Decided to use wrappers which are then used by drivers
    $addedByGliwus() So tbh this is how it would've been anyways, just shown on the diagram
    $addedByGliwus() Also these are now components rather than packages, so the linking is easier
endnote

component drivers{

    struct pressure_sensor_driver{
        __weak void i2c_master_write_read();
        void init(pressure_sensor_driver* driver);

        void stop_measurements();
        void start_measurements();
        void change_settings(uint8_t new_pressure_range);
        bool get_raw_pressure_oneshot(uint8_t* out_pressure);
        bool get_raw_pressure_buffer(uint8_t* out_buffer, uint8_t buffer_size);
        bool get_bar_pressure_oneshot(float* out_pressure);
        bool get_bar_pressure_buffer(float* out_buffer, uint8_t buffer_size);
        uint8_t pressure_range;
        define REG_WHO_AM_I = 0x0F;
    }

    enum pressure_sensor_range{
        RANGE_1 = 0,
        RANGE_2,
        RANGE_3,
        RANGE_4,
    }

    pressure_sensor_driver --o "uses" pressure_sensor_range

    struct accelerometer_driver{
        accelerometer_range set_range;
        __weak void i2c_master_write_read();
        void init(accelerometer_driver* driver);

        void stop_measurements();
        void start_measurements();
        void change_settings(uint8_t new_range);
        bool get_raw_data_oneshot(accelerometer_raw_data* out_data);
        bool get_raw_data_buffer(accelerometer_raw_data* out_buffer, uint8_t buffer_size);
        bool get_data_oneshot(accelerometer_data* out_data);
        bool get_data_buffer(accelerometer_data* out_buffer, uint8_t buffer_size);
    }

    struct accelerometer_raw_data{
        uint8_t acc_x;
        uint8_t acc_y;
        uint8_t acc_z;
    }

    struct accelerometer_data{
        float acc_x;
        float acc_y;
        float acc_z;
    }

    enum accelerometer_range{
        RANGE_1 = 0,
        RANGE_2,
        RANGE_3,
        RANGE_4,
    }

    accelerometer_driver --o "uses" accelerometer_range
    accelerometer_driver --o "uses" accelerometer_raw_data
    accelerometer_driver --o "uses" accelerometer_data

    struct limit_switch_driver{
        void (*touch_callback)(uint32_t timeout);
    }
    note top of limit_switch_driver
        TBD: Think about the callback (button lib hehe)
    endnote

    enum stepper_motor_state{
        IDLE = 0,
        MOVING_CW,
        MOVING_CCW,
        CALIBRATING,
        STOPPED_BY_LIMIT_SWITCH,
    }

    struct stepper_motor_data{
        uint32_t steps;
        stepper_motor_state state;
    }

    struct stepper_motor_driver{
        stepper_motor_data motor_data;
        __weak void spi_master_write_read();
        stepper_motor_data get_motor_data();
    }

    stepper_motor_state -- "uses" stepper_motor_data
    stepper_motor_data o-- "uses" stepper_motor_driver
    limit_switch_driver o-- "uses" stepper_motor_driver

    enum solenoid_state{
        UNDEFINED = 0,
        CLOSE,
        OPEN,
    }

    struct solenoid_driver{
        solenoid_state state = UNDEFINED;
        solenoid_state get_solenoid_state();
    }

    solenoid_state o-- "uses" solenoid_driver

    struct loadcell_driver{
        void init();
        void get_raw_data();
        void get_data();
        void tare();
        void set_calfactor(uint32_t calfactor);
    }

    note top of loadcell_driver
        TBD when we now the model
    endnote



    struct temp_sensor_driver{
        void get_temperature();
    }

    struct distance_sensor_driver{
        void get_distance();
    }

    enum led_state{
        LED_OFF = 0,
        LED_ON,
    }

    struct led_driver{
        led_state state;
        void turn_on();
        void turn_off();
    }

    led_state o-- "uses" led_driver
}

note left of drivers
    Drivers for peripherals
    to be used in the app.
    G for now
endnote

component peripheral_drivers{
    
    component tiny_usb{

    }

    note top of tiny_usb
        $addedByGliwus() External library
    endnote

    struct usb_cdc_driver{
        tiny_usb_config_t *tiny_usb_config;

        void usb_cdc_init(tiny_usb_config_t *_tiny_usb_config);
        void usb_cdc_send(char* data);
        void usb_cdc_receive(char* data);
    }
    note top of usb_cdc_driver
        $addedByGliwus() USB CDC as device -> using TinyUSB library
    endnote

    usb_cdc_driver --o "uses" tiny_usb

    struct i2c_driver{
        i2c_master_write_read();
    }

    struct rtc_driver{
        uint32_t get_time();
    }
    note top of rtc_driver
        TBD: maybe used for log and data
        timestamps synchronization
        get_time() must be global
    endnote

    struct uart_driver{
        void uart_write();
        void uart_read();
    }

    struct spi_driver{
        void spi_master_write_read();
    }
}

component memory{
    struct internal_flash_wrapper{
        void on_log_received(char* log);
    }
    note top of internal_flash_wrapper
        Used for logs
    endnote

    struct sd_card_wrapper{
        void on_log_received(char* log);

    }
    note top of sd_card_wrapper
        TBD: perhaps used for sensor data acquisition
    endnote
}

note right of memory
    All memory
    is global and static
endnote

' CLI and CMD
component cmd{
    struct cmd_parser{
        const char* get_cmd_response();
        void set_cmd_response(char* response);
        char response_buf[RESPONSE_BUF_SIZE];
    }
    note top of cmd_parser
        Parses commands to/from communication interfaces
        Provide responses
        In practice it's a wrapper on ESP-IDF Console
    endnote
}

component logger{

    struct log_receiver{
        void (*on_log_received)(log _log, log_level level);
    }

    struct log_manager{
        void init(log_receiver* receivers, uint8_t num_receivers);
        void log(log _log, log_level level);
        void add_receiver();
        void save_logs();

        queue log_queue;
        uint8_t num_receivers;
        log_receiver receivers[MAX_RECEIVERS];
        uint32_t (*get_time)();
    }

    note left of log_manager::"log(log _log, log_level level)"
    Logs are stored
    in a queue here
endnote
}

component controllers{


struct pneumatic_data{
    uint8_t pressure[MAX_NUMBER_OF_PRESSURE_SENSORS];
    uint8_t solenoid_state[MAX_NUMBER_OF_SOLENOIDS];
}

enum pressure_sensors{
    PRESSURE_SENSOR_1 = 0,
    PRESSURE_SENSOR_2,
    PRESSURE_SENSOR_3,
    MAX_NUMBER_OF_PRESSURE_SENSORS,
}

enum solenoids{
    SOLENOID_1 = 0,
    SOLENOID_2,
    SOLENOID_3,
    SOLENOID_4,
    SOLENOID_5,
    SOLENOID_6,
    MAX_NUMBER_OF_SOLENOIDS,
}

struct pneumatic_control
{
    pressure_sensor_driver* pressure_sensor[MAX_NUMBER_OF_PRESSURE_SENSORS];
    solenoid_driver* solenoid[MAX_NUMBER_OF_SOLENOIDS];

    void init();
    void depressurize_pneumatic_section();
    void pump_pneumatic_section();
    pneumatic_data get_pneumatic_module_data();
}

pneumatic_data o-- "uses" pneumatic_control
pressure_sensors o-- "uses" pneumatic_control
solenoids o-- "uses" pneumatic_control

enum stepper_motors{
    MOTOR_1 = 0,
    MOTOR_2,
    MOTOR_3,
    MOTOR_4,
    MAX_NUMBER_OF_MOTORS,
}

struct motor_data{
    stepper_motor_data motor_data[MAX_NUMBER_OF_MOTORS];

}

struct motor_control{
    stepper_motor_driver* motor_driver[MAX_NUMBER_OF_MOTORS];
    distance_sensor_driver* distance_sensor;
    limit_switch_driver* limit_switch[MAX_NUMBER_OF_MOTORS];

    void init();
    void move_motor(uint8_t motor, uint8_t steps);
    void move_manifold(uint8_t steps);
    void move_test_object(uint8_t steps);
    void calibrate_motor();
    void get_motor_module_data();
}

stepper_motors o-- "uses" motor_control
motor_data o-- "uses" motor_control

struct accelerometer_control{
    accelerometer_driver* acc;
    accelerometer_data acc_data[BUFFER_SIZE];

    void init();
    void get_accelerometer_data();
}

struct loadcell_control{
    loadcell_driver* loadcell;
    loadcell_data loadcell_data[BUFFER_SIZE];
}

struct temp_sensor_control{
    temp_sensor_driver* temp_sensor;
    temp_sensor_data temp_sensor_data[BUFFER_SIZE];
}

struct led_controller{
    led_driver* led;
    void init();
    void turn_on();
    void turn_off();
}

}

note bottom of controllers
Controllers for different tasks
they are global and static

There will be tables with components as described, to easier manage loops etc.,
but the different indices will be used to distinct between sensors, components etc.
Controllers know explicitly about the components

TBD: when we have complete BOM
endnote

component app{
struct preocedure_task{

    void init();
}

struct cli_task{
    cmd_parser* parser;

    void init();
}

note left of cli_task
    TBD: Let's see if observer-actor
    architecture makes sense here
endnote

struct log_task{
    log_manager* manager;

    void init();
}

struct data_acquisition_task{
    void init();

}
}
component procedures{
struct init_procedure{
    void init_procedure();
}
struct main_grab_test_calibrate_procedure{
    void main_grab_test_calibrate_procedure();
}
struct main_grab_test_execute_procedure{
    void main_grab_test_execute_procedure();
}
struct self_test_procedure{
    void self_test_procedure();
}

portin portin1
}

note left of procedures
Only one procedure may be active at a time
endnote

' TODO: think about data acquisition manager
' With saving states

' app -[hidden]u-> drivers
' communication_interfaces -[hidden]d-> logger
' app -[hidden]r-> cmd
' cmd -[hidden]u-> memory
' communication_interfaces -[hidden]l-> drivers
' logger -[hidden]d-> controllers
' controllers -[hidden]d-> procedures

note top of app
Na jutro: opedzlowac procedure task
i zastanowic sie nad data acquisition task (memory)
procedure task bedzie tak:
- cli parsuje komende
- procedure task dostaje notyfikacje i odpalal odpowiednia procedure
poprzez jakas funkcje start

Osobny komponent procedures bedzie definiowal elegancko
jedna niestatyczna funkcje ktora bedzie z kolei wywolywala
reszte statycznych funkcji w odpowiedniej kolejnosci i sie
bedzie skladac na te wlasnie procedure
endnote

@enduml

