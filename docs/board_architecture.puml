@startuml Mainboard_architecture

package communication_interfaces{

    ' TODO: If uart for sure to RPi
    struct uart_interface {
        void on_log_received(char* log);
    }

    note top of uart_interface
        UART: Mainboard <-> RPi.
        Maybe multiple instances as RS485 could be used
    endnote

    struct usb_cdc_interface{
        void on_log_received(char* log);
    }

    note top of usb_cdc_interface
        USB_CDC: Mainboard <-> PC.
    endnote

    struct ble_interface{
        void on_log_received(char* log);
    }

    note top of ble_interface
        BLE: Mainboard <-> PC.
        Turned off by default.
        Used only for ground testing
    endnote

    struct i2c_wrapper{

    }

    struct spi_wrapper{

    }

}

note right of communication_interfaces
    Interfaces for communication
    are global and static
endnote



package drivers{

    struct pressure_sensor_driver{
        __weak void i2c_master_write_read();
        void init(pressure_sensor_driver* driver);

        void stop_measurements();
        void start_measurements();
        void change_settings(uint8_t new_pressure_range);
        uint8_t pressure_range;
        define REG_WHO_AM_I = 0x0F;
    }

    struct imu_driver{
        __weak void i2c_master_write_read();
    }

    struct stepper_motor_driver{
        __weak void spi_master_write_read();
    }

    struct solenoid_driver{

    }

    struct compressor_driver{

    }
    note top of compressor_driver
        Either DC or BLDC motor
    endnote

    struct loadcell_driver{

    }

    struct usb_cdc_driver{

    }
    note top of usb_cdc_driver
        TBD
    endnote

    struct i2c_driver{
        i2c_master_write_read();
    }

    struct rtc_driver{
        uint32_t get_time();
    }
    note top of rtc_driver
        TBD: maybe used for log and data
        timestamps synchronization
        get_time() must be global
    endnote

}

note bottom of drivers
    Drivers for peripherals
    to be used in the app.
    pressure_sensor_driver is the benchmark for now
endnote

package memory{
    struct internal_flash_wrapper{
        void on_log_received(char* log);
    }
    note top of internal_flash_wrapper
        Used for logs
    endnote

    struct sd_card_wrapper{
        void on_log_received(char* log);

    }
    note top of sd_card_wrapper
        TBD: perhaps used for sensor data acquisition
    endnote
}

note right of memory
    All memory
    is global and static
endnote

' CLI and CMD
package cmd{
    struct cmd_parser{
        const char* get_cmd_response();
        void set_cmd_response(char* response);
        char response_buf[RESPONSE_BUF_SIZE];
    }
    note top of cmd_parser
        Parses commands to/from communication interfaces
        Provide responses
        In practice it's a wrapper on ESP-IDF Console
    endnote
}

package logger{

    struct log_receiver{
        void (*on_log_received)(log _log, log_level level);
    }

    struct log_manager{
        void init(log_receiver* receivers, uint8_t num_receivers);
        void log(log _log, log_level level);
        void add_receiver();
        void save_logs();

        queue log_queue;
        uint8_t num_receivers;
        log_receiver receivers[MAX_RECEIVERS];
        uint32_t (*get_time)();
    }

    note left of log_manager::"log(log _log, log_level level)"
    Logs are stored
    in a queue here
    endnote
}

package controllers{
struct pneumatic_control
{
    compressor_driver* driver;
    pressure_sensor_driver* pressure_sensor;

    void init();
    void depressurize_macki();
    void pump_macki();
    void set_tank_pressure(uint8_t pressure);
    void get_pneumatic_module_data();
}

struct motor_control{
    stepper_motor_driver* driver;

    void init();
    void move_manifold(uint8_t steps);
    void move_test_object(uint8_t steps);
    void calibrate_motor();
    void get_motor_data();
}

struct sensor_data_control{
    imu_driver* imu;
    loadcell_driver* loadcell;

    void init();
    void get_imu_data();
    void get_loadcell_data();
}

}
note bottom of controllers
Controllers for different tasks
they are global and static
endnote

package app{
struct preocedure_task{
    compressor_driver* driver;
    pressure_sensor_driver* pressure_sensor;

    void init();
}

struct cli_task{
    cmd_parser* parser;

    void init();
}

note left of cli_task
TBD: Let's see if observer-actor
architecture makes sense here
endnote

struct log_task{
    log_manager* manager;

    void init();
}

}

app -[hidden]d-> communication_interfaces
communication_interfaces -[hidden]d-> logger
app -[hidden]r-> cmd
cmd -[hidden]u-> memory
communication_interfaces -[hidden]l-> drivers
logger -[hidden]d-> controllers



@enduml

